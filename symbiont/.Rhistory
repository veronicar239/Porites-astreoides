xlab("Raw expression counts") +
ylab("Number of genes")
grid.arrange(p1, p2, ncol = 2)
# To get an idea about how RNA-seq counts are distributed, plot counts for a couple samples
p1 <- ggplot(sym_means_filtered) +
geom_histogram(aes(x = NC_291_C_Pa_yr2), stat = "bin", bins = 200) +
xlim(-5, 500)  +
xlab("Raw expression counts") +
ylab("Number of genes")
p2 <- ggplot(sym_means_filtered) +
geom_histogram(aes(x = NC_295_La_Pa_yr2), stat = "bin", bins = 200) +
xlim(-5, 500)  +
xlab("Raw expression counts") +
ylab("Number of genes")
grid.arrange(p1, p2, ncol = 2)
# To get an idea about how RNA-seq counts are distributed, plot counts for a couple samples
p1 <- ggplot(sym_means_filtered) +
geom_histogram(aes(x = NC_291_C_Pa_yr2), stat = "bin", bins = 200) +
xlim(-5, 500)  +
xlab("Raw expression counts") +
ylab("Number of genes")
p2 <- ggplot(sym_means_filtered) +
geom_histogram(aes(x = NO_289_La_Pa_yr2), stat = "bin", bins = 200) +
xlim(-5, 500)  +
xlab("Raw expression counts") +
ylab("Number of genes")
grid.arrange(p1, p2, ncol = 2)
mean_counts <- apply(sym_means_filtered, 1, mean)
variance_counts <- apply(sym_means_filtered, 1, var)
df <- data.frame(mean_counts, variance_counts)
ggplot(df) +
geom_point(aes(x=mean_counts, y=variance_counts)) +
geom_line(aes(x=mean_counts, y=mean_counts, color="red")) +
scale_y_log10() +
scale_x_log10() +
theme(legend.position = "none")
# Check that sample names match in both files
all(colnames(sym_means_filtered) %in% rownames(meta))
all(colnames(sym_means_filtered) == rownames(meta))
# If your data did not match, you could use the match() function to rearrange them to be matching.
levels(meta$group)
# can only do 2 group comparisons (limitation of DESeq2)
dds <- DESeqDataSetFromMatrix(countData = sym_means_filtered,
colData = meta,
design= ~group)
vsdBlindTrue <- DESeq2::varianceStabilizingTransformation(dds, blind = TRUE, fitType = "parametric")
boxplot(assay(vsdBlindTrue), col=meta$group)
vsdBlindFalse <- DESeq2::varianceStabilizingTransformation(dds, blind = FALSE, fitType = "parametric")
boxplot(assay(vsdBlindFalse), col=meta$group)
rlogged.BlindTrue = rlogTransformation(dds, blind = TRUE)
boxplot(assay(rlogged.BlindTrue), col=meta$group)
rlogged.BlindFalse = rlogTransformation(dds, blind = FALSE)
boxplot(assay(rlogged.BlindFalse), col=meta$group)
dds <- estimateSizeFactors(dds)
plot(sort(sizeFactors(dds)))
#sort.list(sizeFactors(dds))
sizeFactors(dds)
order(sizeFactors(dds), decreasing = TRUE)
# to retrieve the normalized counts matrix from dds
normalized_counts <- counts(dds, normalized=TRUE)
rownames(normalized_counts) <- rownames(sym_means_filtered)
# Save normalized counts table as R data file for later use
saveRDS(normalized_counts, file = "counts_normalized_Past_sym.rds")
normalized_counts <- as.data.frame.array(normalized_counts)
setDT(normalized_counts, keep.rownames = "gene")
# Save normalized data matrix for later use:
write.csv(normalized_counts, "counts_normalized_Past_sym.csv", row.names = F)
colSums(counts(dds))[order(colSums(counts(dds)))]
colSums(counts(dds)) %>% barplot(col=meta$group)
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c( "group"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("group")) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = group), size = 2) +
stat_ellipse(geom = "polygon", alpha = 1/10, aes(fill = group)) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c("Origin_name"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("Origin_name") ) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = Origin_name), size = 2) +
stat_ellipse(geom = "polygon", alpha = 1/10, aes(fill = Origin_name)) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c("Destination_name"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("Destination_name") ) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = Destination_name), size = 2) +
stat_ellipse(geom = "polygon", alpha = 1/10, aes(fill = Destination_name)) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c("Colony_ID"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("Colony_ID")) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = Colony_ID), size = 2) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
# sample by distance heatmap
sampleDists <- as.matrix(dist(t(assay(vsdBlindFalse))))
heatmap.2(as.matrix(sampleDists), key=F, trace="none",
col=colorpanel(100, "black", "white"),
margin=c(10, 10))
# Generate normalized counts
# perform the median of ratios method of normalization
# perform a Wald test in DESeq2 pairwise comparison between treatment effects
dds <- DESeq2::DESeq(dds, fitType = "parametric", test = "Wald")
# copy here text from below:
# -- replacing outliers and refitting for 19 genes
# -- DESeq argument 'minReplicatesForReplace' = 7
# -- original counts are preserved in counts(dds)
results.dds = results(dds)
head(results.dds)
dispersionFunction(dds)
# already accomplished as part of DESeq() function (above):
#dds <- DESeq2::estimateSizeFactors(dds)
#dds <- DESeq2::estimateDispersionsGeneEst(dds)
#dds <- DESeq2::estimateDispersionsFit(dds)
#dds <- DESeq2::estimateDispersionsMAP(dds)
DESeq2::plotDispEsts(dds)
# It can be useful to include the sample names in the data set object:
rownames(dds) <- rownames(sym_means_filtered)
levels(dds$group)
results_LO_LC_.1 <- results(dds, contrast = c("group", "Lagoon.Ojo", "Lagoon.Control"), alpha = 0.1)
levels(dds$group)
rownames(mcols(mcols(dds)))
head(dispersions(dds))  # parametric
dispersions(dds) %>% hist(breaks = 500)
results_LO_LC_.1 <- results(dds, contrast = c("group", "Lagoon.Ojo", "Lagoon.Control"), alpha = 0.1)
dds$group
library(RColorBrewer)
library(circlize)
library(pheatmap)
library(gplots) #heatmap.2()
library(ComplexHeatmap)
library(tidyverse)
library(vegan)
library(cowplot)
library(ggrepel)
library(devtools)
library(vsn)
library(dplyr)
library(plyr)
library(ggplot2)
library(knitr)
library(gridExtra)
library(data.table)
# first time installation:
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("DESeq2")
# BiocManager::install("DEGreport")
# BiocManager::install("arrayQualityMetrics")
library(BiocManager)
library(DESeq2)
library(DEGreport)
library(arrayQualityMetrics)
library(locfit)
setwd("~/Documents/Rprojects/postdoc\ Rprojects/ODU_postdoc_Rprojects/Paper_Ojo_gene-expression/Porites_astreoides/symbiont/")
sym <- read.csv("Genes_Sym_OA_ojo.csv", header=TRUE, row.names=1)
dim(sym)
## Some genes were not detected in all samples (genes with zero reads)
sym <- sym[rowSums(sym) > 0, ]
dim(sym)
meta <- read.csv("~/Documents/Rprojects/postdoc\ Rprojects/ODU_postdoc_Rprojects/Paper_Ojo_gene-expression/Porites_astreoides/P_astreoides_Year-2_metadata.csv", header=TRUE, row.names=1)
# Remove all samples that were transplanted to the Destination Ojo.Norte
# There is no control site for Norte Ojo
# For now, we are focused on samples transplanted to Laja Control or Laja Ojo sites
# This is consistent with analyses for the other 2 species in the experiment
# Also, group sample size is too small for Ojo.Norte destination
meta <- subset(meta, Destination_name != "Ojo.Norte")
meta$Origin_type <- revalue(meta$Origin_type, c("control" = "Control", "ojo" = "Ojo"))
meta$Destination_type <- revalue(meta$Destination_type, c("control" = "Control", "ojo" = "Ojo"))
meta$Origin_type <- revalue(meta$Origin_type, c("Control" = "Lagoon"))
meta <- meta %>% unite(group, Origin_type, Destination_type, sep = ".", remove = FALSE)
meta[sapply(meta, is.character)] <- lapply(meta[sapply(meta, is.character)],
as.factor)
# Colony_ID is equivalent to genotype
meta$Colony_ID <- as.factor(meta$Colony_ID)
levels(meta$group)
meta <- dplyr::select(meta, Colony_ID, group, Origin_name, Origin_type, Destination_name, Destination_type, pH_Destination)
## The do.call() function produces a data frame with one col per sample,
## transpose it to obtain one row per sample and one column per statistics.
stats.per.sample <- data.frame(t(do.call(cbind, lapply(sym, summary))))
stats.per.sample$libsum <- apply(sym, 2, sum) ## libsum
stats.per.sample$zeros <- apply(sym==0, 2, sum)
stats.per.sample$percent.zeros <- 100*stats.per.sample$zeros/nrow(sym)
head(stats.per.sample)
par(mfrow=c(3,1))
hist(as.matrix(sym), col="blue", border="white", breaks=50)
hist(as.matrix(sym), col="blue", border="white",
breaks=20000, xlim=c(0,500), main="Counts per gene",
xlab="Counts (truncated axis)", ylab="Number of genes",
las=1, cex.axis=0.7)
epsilon <- 1 # pseudo-count to avoid problems with log(0)
hist(as.matrix(log2(sym + epsilon)), breaks=100, col="blue", border="white",
main="Log2-transformed counts per gene", xlab="log2(counts+1)", ylab="Number of genes",
las=1, cex.axis=0.7)
boxplot(log2(sym + epsilon), col=meta$group, pch=".",
horizontal=TRUE, cex.axis=0.5, las=1,
xlab="log2(Counts +1)")
if(!require("affy")){
source("http://bioconductor.org/biocLite.R")
biocLite("affy")
}
library(affy)
## Each curve corresponds to one sample
plotDensity(log2(sym + epsilon), lty=1, col= meta$group, lwd=2)
grid()
# how many genes have mean count >=3
sym_means_filtered <- cbind(sym, means = apply(sym, 1, mean))
table(sym_means_filtered$means>=3)
sym_means_filtered <- subset(sym_means_filtered, sym_means_filtered$means>=3)
sym_means_filtered <- sym_means_filtered[, 1:40]
dim(sym_means_filtered)
boxplot(log2(sym_means_filtered + epsilon), col=meta$group, pch=".",
horizontal=TRUE, cex.axis=0.5, las=1,
xlab="log2(Counts +1)")
drop <- c("NC_318_N_Pa_yr2", "NO_278_N_Pa_yr2", "NO_266_N_Pa_yr2", "NC_327_N_Pa_yr2", "NO_275_N_Pa_yr2", "NC_293_N_Pa_yr2", "NO_272_N_Pa_yr2", "NC_312_N_Pa_yr2")
sym_means_filtered <- sym_means_filtered[,!(names(sym_means_filtered) %in% drop)]
meta <- meta[!(row.names(meta) %in% drop),]
sym_means_filtered <- droplevels(sym_means_filtered)
meta <- droplevels(meta)
prop.null <- apply(sym_means_filtered, 2, function(x) 100*mean(x==0))
barplot(prop.null, main="Percentage of null counts per sample",
horiz=TRUE, cex.names=0.5, las=1,
col=meta$group, ylab='Samples', xlab='% of null counts')
prop.null[order(prop.null)]
drop <- c("NC_292_La_Pa_yr2", "NC_311_La_Pa_yr2", "NC_320_La_Pa_yr2")
sym_means_filtered <- sym_means_filtered[,!(names(sym_means_filtered) %in% drop)]
meta <- meta[!(row.names(meta) %in% drop),]
prop.null <- apply(sym_means_filtered, 2, function(x) 100*mean(x==0))
prop.null[order(prop.null)]
prop.null <- apply(sym_means_filtered, 2, function(x) 100*mean(x==0))
barplot(prop.null, main="Percentage of null counts per sample",
horiz=TRUE, cex.names=0.5, las=1,
col=meta$group, ylab='Samples', xlab='% of null counts')
meta %>%
group_by(group) %>%
dplyr::summarise(count = n())
# To get an idea about how RNA-seq counts are distributed, plot counts for a couple samples
p1 <- ggplot(sym_means_filtered) +
geom_histogram(aes(x = NC_291_C_Pa_yr2), stat = "bin", bins = 200) +
xlim(-5, 500)  +
xlab("Raw expression counts") +
ylab("Number of genes")
p2 <- ggplot(sym_means_filtered) +
geom_histogram(aes(x = NO_289_La_Pa_yr2), stat = "bin", bins = 200) +
xlim(-5, 500)  +
xlab("Raw expression counts") +
ylab("Number of genes")
grid.arrange(p1, p2, ncol = 2)
mean_counts <- apply(sym_means_filtered, 1, mean)
variance_counts <- apply(sym_means_filtered, 1, var)
df <- data.frame(mean_counts, variance_counts)
ggplot(df) +
geom_point(aes(x=mean_counts, y=variance_counts)) +
geom_line(aes(x=mean_counts, y=mean_counts, color="red")) +
scale_y_log10() +
scale_x_log10() +
theme(legend.position = "none")
# Check that sample names match in both files
all(colnames(sym_means_filtered) %in% rownames(meta))
all(colnames(sym_means_filtered) == rownames(meta))
# If your data did not match, you could use the match() function to rearrange them to be matching.
levels(meta$group)
# can only do 2 group comparisons (limitation of DESeq2)
dds <- DESeqDataSetFromMatrix(countData = sym_means_filtered,
colData = meta,
design= ~group)
vsdBlindTrue <- DESeq2::varianceStabilizingTransformation(dds, blind = TRUE, fitType = "parametric")
boxplot(assay(vsdBlindTrue), col=meta$group)
vsdBlindFalse <- DESeq2::varianceStabilizingTransformation(dds, blind = FALSE, fitType = "parametric")
boxplot(assay(vsdBlindFalse), col=meta$group)
rlogged.BlindTrue = rlogTransformation(dds, blind = TRUE)
boxplot(assay(rlogged.BlindTrue), col=meta$group)
rlogged.BlindFalse = rlogTransformation(dds, blind = FALSE)
boxplot(assay(rlogged.BlindFalse), col=meta$group)
# this gives log2(n + 1)
ntd <- normTransform(dds)
meanSdPlot(assay(ntd))
meanSdPlot(assay(vsdBlindTrue))
meanSdPlot(assay(vsdBlindFalse))
meanSdPlot(assay(rlogged.BlindTrue))
meanSdPlot(assay(rlogged.BlindFalse))
dists.rlog.BlindFalse <- dist(t(assay(rlogged.BlindFalse)))
plot(hclust(dists.rlog.BlindFalse))
dists.vsdBlindFalse <- dist(t(assay(vsdBlindFalse)))
plot(hclust(dists.vsdBlindFalse))
# save varianceStabilizingTransformation counts
saveRDS(vsdBlindFalse, file = "counts_vst.BlindFalse_Past_sym.rds")
# later, after you already created the file, can load the existing file:
#vsdBlindFalse <- readRDS("counts_vst.BlindFalse_Past_sym.rds")
dds <- estimateSizeFactors(dds)
plot(sort(sizeFactors(dds)))
#sort.list(sizeFactors(dds))
sizeFactors(dds)
order(sizeFactors(dds), decreasing = TRUE)
# to retrieve the normalized counts matrix from dds
normalized_counts <- counts(dds, normalized=TRUE)
rownames(normalized_counts) <- rownames(sym_means_filtered)
# Save normalized counts table as R data file for later use
saveRDS(normalized_counts, file = "counts_normalized_Past_sym.rds")
normalized_counts <- as.data.frame.array(normalized_counts)
setDT(normalized_counts, keep.rownames = "gene")
# Save normalized data matrix for later use:
write.csv(normalized_counts, "counts_normalized_Past_sym.csv", row.names = F)
colSums(counts(dds))[order(colSums(counts(dds)))]
colSums(counts(dds)) %>% barplot(col=meta$group)
# How do the numbers correlate with the size factor?
# Now take a look at the total depth after normalization using:
#colSums(counts(dds, normalized=T))
colSums(counts(dds, normalized=T))[order(colSums(counts(dds, normalized=T)))]
colSums(counts(dds, normalized = T)) %>% barplot(col=meta$group)
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c( "group"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("group")) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = group), size = 2) +
stat_ellipse(geom = "polygon", alpha = 1/10, aes(fill = group)) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c("Origin_name"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("Origin_name") ) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = Origin_name), size = 2) +
stat_ellipse(geom = "polygon", alpha = 1/10, aes(fill = Origin_name)) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c("Destination_name"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("Destination_name") ) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = Destination_name), size = 2) +
stat_ellipse(geom = "polygon", alpha = 1/10, aes(fill = Destination_name)) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
pcadata = DESeq2::plotPCA(vsdBlindFalse, intgroup = c("Colony_ID"), returnData = TRUE)
percentVar = round(100 * attr(pcadata, "percentVar"))
pca = prcomp(t(assay(vsdBlindFalse)), center = TRUE, scale. = FALSE)
DESeq2::plotPCA(vsdBlindFalse, returnData = TRUE, intgroup = c("Colony_ID")) %>%
ggplot(aes(x = PC1, y = PC2)) +
geom_point(aes(colour = Colony_ID), size = 2) +
xlab(paste0("PC1: ",percentVar[1],"% variance")) +
ylab(paste0("PC2: ",percentVar[2],"% variance")) +
theme_cowplot()
rld_mat <- assay(vsdBlindFalse)
rld_cor <- cor(rld_mat)
#head(rld_cor)   ## check the output of cor(), make note of the rownames and colnames
pheatmap(rld_cor)
# sample by distance heatmap
sampleDists <- as.matrix(dist(t(assay(vsdBlindFalse))))
heatmap.2(as.matrix(sampleDists), key=F, trace="none",
col=colorpanel(100, "black", "white"),
margin=c(10, 10))
# Generate normalized counts
# perform the median of ratios method of normalization
# perform a Wald test in DESeq2 pairwise comparison between treatment effects
dds <- DESeq2::DESeq(dds, fitType = "parametric", test = "Wald")
# copy here text from below:
# -- replacing outliers and refitting for 31 genes
# -- DESeq argument 'minReplicatesForReplace' = 7
# -- original counts are preserved in counts(dds)
results.dds = results(dds)
head(results.dds)
View(sym_means_filtered)
View(meta)
headresults(dds)
head(results(dds))
results(dds)$
results_LO_LC_.1 <- results(dds, contrast = c("group", "Lagoon.Ojo", "Lagoon.Control"), alpha = 0.1)
dds$group
View(sym)
resultsNames(dds)
resultsNames(dds)
Names(dds)
View(dds)
dds@NAMES
dds@NAMES
?results
mcols(results.dds)
?resultsNames
removeResults(dds)
results_LO_LC_.1 <- results(dds, contrast = c("group", "Lagoon.Ojo", "Lagoon.Control"), alpha = 0.1)
levels(meta$group)
View(meta)
View(sym_means_filtered)
View(sym_means_filtered)
all(colnames(sym_means_filtered) %in% rownames(meta))
all(colnames(sym_means_filtered) == rownames(meta))
# If your data did not match, you could use the match() function to rearrange them to be matching.
meta %>%
group_by(group) %>%
dplyr::summarise(count = n())
levels(dds$group)
# Generate normalized counts
# perform the median of ratios method of normalization
# perform a Wald test in DESeq2 pairwise comparison between treatment effects
dds <- DESeq2::DESeq(dds, fitType = "parametric", test = "Wald")
# copy here text from below:
# -- replacing outliers and refitting for 31 genes
# -- DESeq argument 'minReplicatesForReplace' = 7
# -- original counts are preserved in counts(dds)
dds@NAMES
rownames(mcols(mcols(dds)))
head(dispersions(dds))  # parametric
# already accomplished as part of DESeq() function (above):
#dds <- DESeq2::estimateSizeFactors(dds)
#dds <- DESeq2::estimateDispersionsGeneEst(dds)
#dds <- DESeq2::estimateDispersionsFit(dds)
#dds <- DESeq2::estimateDispersionsMAP(dds)
DESeq2::plotDispEsts(dds)
# It can be useful to include the sample names in the data set object:
rownames(dds) <- rownames(sym_means_filtered)
levels(dds$group)
results_LO_LC_.1 <- results(dds, contrast = c("group", "Lagoon.Ojo", "Lagoon.Control"), alpha = 0.1)
coef %in% resultsNames(dds)
contrasts(dds)
meta <- read.csv("~/Documents/Rprojects/postdoc\ Rprojects/ODU_postdoc_Rprojects/Paper_Ojo_gene-expression/Porites_astreoides/P_astreoides_Year-2_metadata.csv", header=TRUE, row.names=1)
# Remove all samples that were transplanted to the Destination Ojo.Norte
# There is no control site for Norte Ojo
# For now, we are focused on samples transplanted to Laja Control or Laja Ojo sites
# This is consistent with analyses for the other 2 species in the experiment
# Also, group sample size is too small for Ojo.Norte destination
meta <- subset(meta, Destination_name != "Ojo.Norte")
View(meta)
meta$Origin_type <- revalue(meta$Origin_type, c("control" = "Control", "ojo" = "Ojo"))
meta$Destination_type <- revalue(meta$Destination_type, c("control" = "Control", "ojo" = "Ojo"))
meta$Origin_type <- revalue(meta$Origin_type, c("Control" = "Lagoon"))
meta <- meta %>% unite(group, Origin_type, Destination_type, sep = ".", remove = FALSE)
meta[sapply(meta, is.character)] <- lapply(meta[sapply(meta, is.character)],
as.factor)
# Colony_ID is equivalent to genotype
meta$Colony_ID <- as.factor(meta$Colony_ID)
levels(meta$group)
meta <- dplyr::select(meta, Colony_ID, group, Origin_name, Origin_type, Destination_name, Destination_type, pH_Destination)
drop <- c("NC_318_N_Pa_yr2", "NO_278_N_Pa_yr2", "NO_266_N_Pa_yr2", "NC_327_N_Pa_yr2", "NO_275_N_Pa_yr2", "NC_293_N_Pa_yr2", "NO_272_N_Pa_yr2", "NC_312_N_Pa_yr2")
sym_means_filtered <- sym_means_filtered[,!(names(sym_means_filtered) %in% drop)]
meta <- meta[!(row.names(meta) %in% drop),]
sym_means_filtered <- droplevels(sym_means_filtered)
meta <- droplevels(meta)
drop <- c("NC_292_La_Pa_yr2", "NC_311_La_Pa_yr2", "NC_320_La_Pa_yr2")
sym_means_filtered <- sym_means_filtered[,!(names(sym_means_filtered) %in% drop)]
meta <- meta[!(row.names(meta) %in% drop),]
prop.null <- apply(sym_means_filtered, 2, function(x) 100*mean(x==0))
prop.null[order(prop.null)]
all(colnames(sym_means_filtered) %in% rownames(meta))
all(colnames(sym_means_filtered) == rownames(meta))
# If your data did not match, you could use the match() function to rearrange them to be matching.
meta %>%
group_by(group) %>%
dplyr::summarise(count = n())
# Check that sample names match in both files
all(colnames(sym_means_filtered) %in% rownames(meta))
all(colnames(sym_means_filtered) == rownames(meta))
# If your data did not match, you could use the match() function to rearrange them to be matching.
# can only do 2 group comparisons (limitation of DESeq2)
dds <- DESeq2::DESeqDataSetFromMatrix(countData = sym_means_filtered,
colData = meta,
design= ~group)
levels(dds$group)
vsdBlindFalse <- DESeq2::varianceStabilizingTransformation(dds, blind = FALSE, fitType = "parametric")
boxplot(assay(vsdBlindFalse), col=meta$group)
dds <- estimateSizeFactors(dds)
plot(sort(sizeFactors(dds)))
#sort.list(sizeFactors(dds))
sizeFactors(dds)
order(sizeFactors(dds), decreasing = TRUE)
# to retrieve the normalized counts matrix from dds
normalized_counts <- counts(dds, normalized=TRUE)
rownames(normalized_counts) <- rownames(sym_means_filtered)
# Save normalized counts table as R data file for later use
saveRDS(normalized_counts, file = "counts_normalized_Past_sym.rds")
normalized_counts <- as.data.frame.array(normalized_counts)
setDT(normalized_counts, keep.rownames = "gene")
# Save normalized data matrix for later use:
write.csv(normalized_counts, "counts_normalized_Past_sym.csv", row.names = F)
colSums(counts(dds))[order(colSums(counts(dds)))]
colSums(counts(dds)) %>% barplot(col=meta$group)
# How do the numbers correlate with the size factor?
# Now take a look at the total depth after normalization using:
#colSums(counts(dds, normalized=T))
colSums(counts(dds, normalized=T))[order(colSums(counts(dds, normalized=T)))]
colSums(counts(dds, normalized = T)) %>% barplot(col=meta$group)
# Generate normalized counts
# perform the median of ratios method of normalization
# perform a Wald test in DESeq2 pairwise comparison between treatment effects
dds <- DESeq2::DESeq(dds, fitType = "parametric", test = "Wald")
# copy here text from below:
# -- replacing outliers and refitting for 31 genes
# -- DESeq argument 'minReplicatesForReplace' = 7
# -- original counts are preserved in counts(dds)
resultsNames(dds)
dds@NAMES
rm(list=ls())
